<!-- 米に塗られる
マウスにカメラがついてくる
3Dモデルからリンク先へ飛べる-->


<!DOCTYPE html>
<html lang="ja">
<head>
	<title>musenmai</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link rel="icon" type="image/png" href="img/logo_brack.png" sizes="16x16">
    <link rel="icon" type="image/png" href="img/logo_brack.png" sizes="32x32">
    <link rel="icon" type="image/png" href="img/logo_brack.png" sizes="96x96">

	<style>
		body {
			background:#000;
			padding:0;
			margin:0;
			overflow:hidden;
		}
		#info {
			position: absolute;
			top: 30px;
			width: 100%;
			color: #ffffff;
			padding: 5px;
			font-family:Monospace;
			font-size:15px;
			text-align:center;
		}
		a {
			color: #ffffff;
		}
	</style>

	<script src="js/three.js"></script>
	<script src="js/3Dink.js"></script>
	<script src="js/DecalGeometry.js"></script>
	<script src="js/dat.gui.min.js"></script>
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.2.0/css/all.css" integrity="sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ" crossorigin="anonymous">


</head>
<body>

<div id="info">
	<a href="about.html">about</a>
	demo
	<a href="https://github.com/musenmai01"><i class="fab fa-github"></i></a>
</div>

<div id="container"></div>


<script>

	var container = document.getElementById( 'container' );

	var camera, scene, renderer;
	var mouseX = 0, mouseY = 0;
	var windowHalfX = window.innerWidth / 2;
	var windowHalfY = window.innerHeight / 2;


	var mesh, decal;
	var raycaster;

	var intersection = {
		intersects: false,
		point: new THREE.Vector3(),
		normal: new THREE.Vector3()
	};
	var mouse = new THREE.Vector2();
	var textureLoader = new THREE.TextureLoader();


	var decalDiffuse = textureLoader.load('img/13.png');

	var decalMaterial = new THREE.MeshBasicMaterial( {
		map: decalDiffuse,
		transparent: true,
		depthWrite: false,
		polygonOffset: true,
		polygonOffsetFactor: -10,
		wireframe: false
	} );

	var decals = [];
	var position = new THREE.Vector3();
	var orientation = new THREE.Euler();
	var size = new THREE.Vector3( 10, 10, 10 );

	var params = {
		minScale: 20,
		maxScale: 40,
		rotate: true,
		clear: function() {

			removeDecals();

		}
	};


	init();
	animate();

	function init()
	{
		renderer = new THREE.WebGLRenderer( { antialias: true } );

		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );

		container.appendChild( renderer.domElement );
		document.addEventListener( 'mousemove', onDocumentMouseMove, false );
		window.addEventListener( 'resize', onWindowResize, false );

		var moved = false;

		window.addEventListener( 'mousedown', function () {
			moved = false;
		}, false );
		window.addEventListener( 'mouseup', function() {
			checkIntersection();
			if ( ! moved && intersection.intersects ) shoot();
		} );

		window.addEventListener( 'mousemove', onTouchMove );
		window.addEventListener( 'touchmove', onTouchMove );

		camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 10000 );
		camera.position.z = 95;
		scene = new THREE.Scene();
		scene.background = new THREE.Color( 0x000000 );

		// light
		var light = new THREE.DirectionalLight(0xffffff, 1);
		light.position.set(10, 30, 5);
		light.castShadow = true;
		scene.add(light);
		var ambient = new THREE.AmbientLight(0xffffff);
		scene.add(ambient);

		// リンク追加
		DDDINK.readRendererObj(renderer, scene, camera);
		DDDINK.domEvent.addFnc('Fn','Fn');



		//Blenderで作った3Dモデルを読み込む
		//無洗米（日本語テキストがないからBlenderで作った）
        var loader = new THREE.JSONLoader();
        loader.load( '3D/musenmai.json', function(geometry, materials)
		{
            var material = new THREE.MeshBasicMaterial(materials);
            musenmai = new THREE.Mesh(geometry, material);
            musenmai.position.set(-16, 10, 40);
            musenmai.rotation.set(0, -Math.PI/2.35, 0);
            musenmai.scale.set(10, 10, 10);
            scene.add(musenmai);
        });
		//logo
		var loader = new THREE.JSONLoader();
		loader.load( '3D/logo.json', function(geometry, materials)
		{
			var material = new THREE.MeshBasicMaterial(materials);
			musenmai = new THREE.Mesh(geometry, material);
			musenmai.position.set(-36, 10, 45);
			musenmai.rotation.set(0, Math.PI/10, 0);
			musenmai.scale.set(3, 3, 3);
			scene.add(musenmai);
		});


		//３Dの文字（コンテンツ）
        var loader = new THREE.FontLoader();
        loader.load( 'font/optimer_regular.typeface.json', function(font)
		{
        	var textGeometry1 = new THREE.TextGeometry("8/4 12:00 - 19:00", {
        		font: font,
        		size: 2.5,
        		height: 0.5,
        		curveSegments: 12
        	});
            var textGeometry2 = new THREE.TextGeometry("8/5 10:00 - 18:00", {
        		font: font,
        		size: 2.5,
        		height: 0.5,
        		curveSegments: 12
        	});
            var textGeometry3 = new THREE.TextGeometry("B / 03-02", {
        		font: font,
        		size: 3,
        		height: 0.5,
        		curveSegments: 12
        	});
        	var materials = new THREE.MeshBasicMaterial({color: 0xffffff});
        	var a = new THREE.Mesh(textGeometry1, materials);
            a.position.set(-28, 0, 40);
			a.rotation.set(0, Math.PI/20, 0);
            var b = new THREE.Mesh(textGeometry2, materials);
            b.position.set(-28, -8, 40);
			b.rotation.set(0, Math.PI/20, 0);
            var c = new THREE.Mesh(textGeometry3, materials);
            c.position.set(-24, -16, 40);
			c.rotation.set(0, Math.PI/20, 0);

            scene.add(a);
            scene.add(b);
        	scene.add(c);

			DDDINK.addURL(c, 'proto_nuru01.html');


        });


		var geometry = new THREE.Geometry();
		geometry.vertices.push( new THREE.Vector3(), new THREE.Vector3() );

		okome();

		raycaster = new THREE.Raycaster();

		function onTouchMove(event)
		{
			var x, y;

			if (event.changedTouches)
			{
				x = event.changedTouches[ 0 ].pageX;
				y = event.changedTouches[ 0 ].pageY;
			} else {
				x = event.clientX;
				y = event.clientY;
			}

			mouse.x = ( x / window.innerWidth ) * 2 - 1;
			mouse.y = - ( y / window.innerHeight ) * 2 + 1;

			checkIntersection();
		}

		function checkIntersection()
		{
			if ( ! mesh ) return;

			raycaster.setFromCamera(mouse, camera);

			var intersects = raycaster.intersectObjects([mesh]);

			if ( intersects.length > 0 )
			{
				var p = intersects[ 0 ].point;
				intersection.point.copy( p );

				var n = intersects[ 0 ].face.normal.clone();
				n.multiplyScalar( 10 );
				n.add( intersects[ 0 ].point );

				intersection.normal.copy( intersects[ 0 ].face.normal );
				intersection.intersects = true;

			}else{
				intersection.intersects = false;
			}
		}


		//調節
		var gui = new dat.GUI();
		gui.add( params, 'clear' );
		gui.open();

	}


	function okome( callback )
	{
		var loader = new THREE.JSONLoader();

		loader.load( '3D/okome.json', function( geometry )
		{
			var materials = new THREE.MeshBasicMaterial({color: 0xffffff});
			mesh = new THREE.Mesh( geometry, materials );
			scene.add( mesh );
			mesh.position.set(60, -97, -30);
			mesh.rotation.set(0, Math.PI, 0);
			mesh.scale.set( 39, 39, 39 );
		} );
	}


	//塗り用
	function shoot()
	{
		position.copy( intersection.point );

		orientation.z = Math.random() * 2 * Math.PI;

		var scale = params.minScale + Math.random() * ( params.maxScale - params.minScale );
		size.set( scale, scale, scale );

		var material = decalMaterial.clone();
		material.color.setHSL(360 * Math.random(), 1, 0.65);

		var m = new THREE.Mesh( new THREE.DecalGeometry( mesh, position, orientation, size ), material );

		decals.push( m );
		scene.add( m );
	}



	//塗りのクリア
	function removeDecals()
	{
		decals.forEach( function( d )
		{
			scene.remove( d );
		} );
		decals = [];
	}



	//動くもの
	function animate()
	{
		requestAnimationFrame( animate );
		render();
	}


	function onDocumentMouseMove( event )
	{
		mouseX = ( event.clientX - windowHalfX );
		mouseY = ( event.clientY - windowHalfY );
	}

	//レンダリング
	function render()
	{
		camera.position.x += ( mouseX - camera.position.x * 50 ) * 0.00029;
		camera.position.y += ( - mouseY - camera.position.y * 30 ) * 0.0029;

		camera.lookAt( scene.position );
		renderer.render( scene, camera );
	}


	//可変なウィンドウサイズにする
	function onWindowResize()
	{
		windowHalfX = window.innerWidth / 2;
		windowHalfY = window.innerHeight / 2;
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setSize( window.innerWidth, window.innerHeight );
	}


</script>



</body>
</html>
